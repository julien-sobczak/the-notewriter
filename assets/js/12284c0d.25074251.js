"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2334],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=d(t),u=r,h=p["".concat(s,".").concat(u)]||p[u]||m[u]||i;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1568:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:4},o="From Scratch",l={unversionedId:"developers/from-scratch",id:"developers/from-scratch",title:"From Scratch",description:"The goal of this document is to write a basic version of The NoteWriter to emphasize the core abstractions and the main logic.",source:"@site/docs/developers/from-scratch.md",sourceDirName:"developers",slug:"/developers/from-scratch",permalink:"/the-notewriter/docs/developers/from-scratch",draft:!1,editUrl:"https://github.com/julien-sobczak/the-notewriter/tree/main/website/docs/developers/from-scratch.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"documentationSidebar",previous:{title:"Contributing",permalink:"/the-notewriter/docs/developers/contributing"}},s={},d=[{value:"The Model",id:"the-model",level:2},{value:"<code>File</code>",id:"file",level:3},{value:"<code>Note</code>",id:"note",level:3},{value:"<code>ParsedXXX</code>",id:"parsedxxx",level:3},{value:"The Collection",id:"the-collection",level:2},{value:"The Database",id:"the-database",level:2},{value:"Transactions",id:"transactions",level:3},{value:"The Commands",id:"the-commands",level:2},{value:"<code>add</code>",id:"add",level:3},{value:"<code>commit</code>",id:"commit",level:3}],c={toc:d},p="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(p,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"from-scratch"},"From Scratch"),(0,r.kt)("p",null,"The goal of this document is to write a basic version of ",(0,r.kt)("em",{parentName:"p"},"The NoteWriter")," to emphasize the core abstractions and the main logic."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"We will implement a basic version supporting only the commands ",(0,r.kt)("inlineCode",{parentName:"p"},"nt add")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nt commit"),", and only the objects ",(0,r.kt)("inlineCode",{parentName:"p"},"File")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Note")," (no flashcards, medias, etc.). We ignore configuration too."),(0,r.kt)("p",{parentName:"admonition"},"The source code is available in this same repository under the directory ",(0,r.kt)("inlineCode",{parentName:"p"},"cmd/ntlite/"),".")),(0,r.kt)("h2",{id:"the-model"},"The Model"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"The NoteWriter")," extract objects from Markdown files that will be stored inside ",(0,r.kt)("inlineCode",{parentName:"p"},"nt/objects")," in YAML and inside ",(0,r.kt)("inlineCode",{parentName:"p"},"nt/database.db")," using SQL tables (useful for speed up queries + the full-text search support)."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-md",metastring:"title=notes.md",title:"notes.md"},"# My Notes\n\n## Note: Example 1\n\nA first note.\n\n## Note: Example 2\n\nA second note.\n")),(0,r.kt)("p",null,"This document generates 3 objects: 1 ",(0,r.kt)("em",{parentName:"p"},"file")," (",(0,r.kt)("inlineCode",{parentName:"p"},"notes.md"),") and 2 ",(0,r.kt)("em",{parentName:"p"},"notes")," (",(0,r.kt)("inlineCode",{parentName:"p"},"Note: Example 1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Note: Example 2"),")."),(0,r.kt)("h3",{id:"file"},(0,r.kt)("inlineCode",{parentName:"h3"},"File")),(0,r.kt)("p",null,"Here is the definition of the object ",(0,r.kt)("inlineCode",{parentName:"p"},"File")," simplified for this document:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type File struct {\n    // A unique identifier among all files\n    OID string `yaml:"oid"`\n\n    // A relative path to the collection directory\n    RelativePath string `yaml:"relative_path"`\n\n    // Size of the file (can be useful to detect changes)\n    Size int64 `yaml:"size"`\n    // Hash of the content (can be useful to detect changes too)\n    Hash string `yaml:"hash"`\n    // Content last modification date\n    MTime time.Time `yaml:"mtime"`\n\n    Body string `yaml:"body"`\n\n    CreatedAt     time.Time `yaml:"created_at"`\n    UpdatedAt     time.Time `yaml:"updated_at"`\n    DeletedAt     time.Time `yaml:"deleted_at,omitempty"`\n    LastCheckedAt time.Time `yaml:"-"`\n\n    new   bool\n    stale bool\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The complete model ",(0,r.kt)("inlineCode",{parentName:"p"},"File")," contains additional fields like a reference to a parent file, a title extracted from the text, etc.")),(0,r.kt)("p",null,"Basically, we persist various metadata about the file to quickly determine if a file has changed when running the command ",(0,r.kt)("inlineCode",{parentName:"p"},"ntlite add"),". In addition:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each object get assigned an OID (a unique 40-character string like the hash of Git objects). This OID is used as the primary key inside the SQL database and can be used with the official command ",(0,r.kt)("inlineCode",{parentName:"li"},"nt cat-file <oid>")," to get the full information about an object."),(0,r.kt)("li",{parentName:"ul"},"Each object includes various timestamps. The creation and last modification dates are mostly informative. The timestamp ",(0,r.kt)("inlineCode",{parentName:"li"},"LastCheckedAt")," is updated every time an object is traversed (even if the object hasn't changed) and is useful to quickly find all deleted objects."),(0,r.kt)("li",{parentName:"ul"},"Each object uses Go struct tags to make easy to serialize them in YAML."),(0,r.kt)("li",{parentName:"ul"},"Each object includes the fields ",(0,r.kt)("inlineCode",{parentName:"li"},"new")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"stale")," to determine if a change must be saved and if the object must be inserted or updated.")),(0,r.kt)("h3",{id:"note"},(0,r.kt)("inlineCode",{parentName:"h3"},"Note")),(0,r.kt)("p",null,"Here is the definition of the similar struct ",(0,r.kt)("inlineCode",{parentName:"p"},"Note"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type Note struct {\n    OID string `yaml:"oid"`\n\n    // File containing the note\n    FileOID string `yaml:"file_oid"`\n\n    // Title of the note without leading # characters\n    Title string `yaml:"title"`\n\n    // The filepath of the file containing the note (denormalized field)\n    RelativePath string `yaml:"relative_path"`\n\n    // Content in various formats (best for editing, rendering, writing, etc.)\n    Content string `yaml:"content_raw"`\n    Hash    string `yaml:"content_hash"`\n\n    CreatedAt     time.Time `yaml:"created_at"`\n    UpdatedAt     time.Time `yaml:"updated_at"`\n    DeletedAt     time.Time `yaml:"deleted_at,omitempty"`\n    LastCheckedAt time.Time `yaml:"-"`\n\n    new   bool\n    stale bool\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The complete model ",(0,r.kt)("inlineCode",{parentName:"p"},"Note")," contains a lot more fields. Notes represent the core abstraction. They can have a list of attributes, tags, a parent note (when notes are nested to inherit from parent's attributes), and their content is converted into different representations (Markdown/HTML/Text) to render them easily in various contexts.")),(0,r.kt)("h3",{id:"parsedxxx"},(0,r.kt)("inlineCode",{parentName:"h3"},"ParsedXXX")),(0,r.kt)("p",null,"The structs ",(0,r.kt)("inlineCode",{parentName:"p"},"File")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Note")," must be populated by parsing Markdown files but to make easy to test the parsing logic, we will use basic structs to ignore some of the complexity (for example, ",(0,r.kt)("inlineCode",{parentName:"p"},"Note")," contains the logic to enrich the Markdown and convert it to HTML). This is the intent behind the structs ",(0,r.kt)("inlineCode",{parentName:"p"},"ParsedXXX"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type ParsedFile struct {\n    // The paths to the file\n    AbsolutePath string\n    RelativePath string\n\n    // Stat\n    Stat fs.FileInfo\n\n    // The raw content bytes\n    Bytes []byte\n\n    // The file content\n    Body string\n}\n\ntype ParsedNote struct {\n    // Heading\n    Title   string\n    // Content inside the heading\n    Content string\n}\n")),(0,r.kt)("p",null,"The logic to initialize a ",(0,r.kt)("inlineCode",{parentName:"p"},"ParsedFile")," simply uses the standard Go librairies:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// ParseFile contains the main logic to parse a raw note file.\nfunc ParseFile(relativePath string) (*ParsedFile, error) {\n    absolutePath := filepath.Join(CurrentCollection().Path, relativePath)\n\n    lstat, err := os.Lstat(absolutePath)\n    if err != nil {\n        return nil, err\n    }\n\n    contentBytes, err := os.ReadFile(absolutePath)\n    if err != nil {\n        return nil, err\n    }\n\n    body := strings.TrimSpace(string(contentBytes))\n    return &ParsedFile{\n        AbsolutePath: absolutePath,\n        RelativePath: relativePath,\n        Stat:         lstat,\n        Bytes:        contentBytes,\n        Body:         body,\n    }, nil\n}\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"The NoteWriter")," supports attributes and tags using a YAML Front Matter and a special syntax. The actual parser extracts these metadata used to enrich notes and make them easily searchable.")),(0,r.kt)("p",null,"The logic to initialize ",(0,r.kt)("inlineCode",{parentName:"p"},"ParsedNote")," is slightly more elaborate:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'\n// ParseNotes extracts the notes from a file body.\nfunc ParseNotes(fileBody string) []*ParsedNote {\n    var noteTitle string\n    var noteContent strings.Builder\n\n    var results []*ParsedNote\n\n    for _, line := range strings.Split(fileBody, "\\n") {\n        // Minimalist implementation. Only search for ## headings\n        if strings.HasPrefix(line, "## ") {\n            if noteTitle != "" {\n                results = append(results, &ParsedNote{\n                    Title:   noteTitle,\n                    Content: strings.TrimSpace(noteContent.String()),\n                })\n            }\n            noteTitle = strings.TrimPrefix(line, "## ")\n            noteContent.Reset()\n            continue\n        }\n\n        if noteTitle != "" {\n            noteContent.WriteString(line)\n            noteContent.WriteRune(\'\\n\')\n        }\n    }\n    if noteTitle != "" {\n        results = append(results, &ParsedNote{\n            Title:   noteTitle,\n            Content: strings.TrimSpace(noteContent.String()),\n        })\n    }\n\n    return results\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"The NoteWriter")," supports nested notes (you can define notes at any level in your Markdown documents) which makes the actual parsing logic more obscure. In addition, the actual logic must also ignore code blocks where ",(0,r.kt)("inlineCode",{parentName:"p"},"#")," is a common character that must not be considered as valid Markdown heading.")),(0,r.kt)("p",null,"The target objects can be initalized from these structs easily:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func NewFileFromParsedFile(parsedFile *ParsedFile) *File {\n    return &File{\n        OID:          NewOID(),\n        RelativePath: parsedFile.RelativePath,\n        Size:         parsedFile.Stat.Size(),\n        Hash:         Hash(parsedFile.Bytes),\n        MTime:        parsedFile.Stat.ModTime(),\n        Body:         parsedFile.Body,\n        CreatedAt:    time.Now(),\n        UpdatedAt:    time.Now(),\n        stale:        true,\n        new:          true,\n    }\n}\n\nfunc NewNoteFromParsedNote(f *File, parsedNote *ParsedNote) *Note {\n    return &Note{\n        OID:          NewOID(),\n        FileOID:      f.OID,\n        Title:        parsedNote.Title,\n        RelativePath: f.RelativePath,\n        Content:      parsedNote.Content,\n        Hash:         Hash([]byte(parsedNote.Content)),\n        CreatedAt:    time.Now(),\n        UpdatedAt:    time.Now(),\n        stale:        true,\n        new:          true,\n    }\n}\n")),(0,r.kt)("p",null,"As explained before, the OIDs uses the same format as Git (SHA1) but are not determined from a hash of the content. If the content of a note (or a flashcard) is edited, we want to update the old object (when Git stores a new file in this case). Therefore, the OID are in fact disguised UUID under the hood:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func NewOID() string {\n    // Ex (Git): 5e3f1b351782c017590b4b70fee709bf9c83b050\n    // Ex (UUIDv4): 123e4567-e89b-12d3-a456-426655440000\n\n    // Remove `-` + add 8 random characters\n    oid := strings.ReplaceAll(uuid.New().String()+uuid.New().String(), "-", "")[0:40]\n    return oid\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"SHA1 are only used when storing blobs (aka medias files), not covered in this document.")),(0,r.kt)("h2",{id:"the-collection"},"The Collection"),(0,r.kt)("p",null,"Now that we know how to parse Markdown files, we need to write the logic to traverse the file system. Most commands will have to process the  complete set of all note files, that are represented by the struct ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Collection struct {\n    Path string\n}\n")),(0,r.kt)("p",null,"The collection will be useful from many places inside the code to resolve absolute paths (the actual code contains a lot more methods) and is defined as a singleton (preferable compared to a global variable to initialize it lazily)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"var (\n    collectionOnce      sync.Once\n    collectionSingleton *Collection\n)\n\nfunc CurrentCollection() *Collection {\n    collectionOnce.Do(func() {\n        cwd, err := os.Getwd()\n        if err != nil {\n            log.Fatal(err)\n        }\n        collectionSingleton = &Collection{\n            Path: cwd,\n        }\n    })\n    return collectionSingleton\n}\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The same pattern is used for different global objects: to retrieve the database connection using ",(0,r.kt)("inlineCode",{parentName:"p"},"CurrentDB()"),", the configuration using ",(0,r.kt)("inlineCode",{parentName:"p"},"CurrentConfig()"),", the logger using ",(0,r.kt)("inlineCode",{parentName:"p"},"CurrentLogger()"),", etc. Using singletons can be challenging in some environments, for example when reading the instance from multiple goroutines or to replace with a test double. ",(0,r.kt)("em",{parentName:"p"},"The NoteWriter")," is a CLI running short-lived commands and tests are using the same dependencies like SQLite.")),(0,r.kt)("p",null,"We define a convenient method to locate the note files:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func (c *Collection) walk(fn func(path string, stat fs.FileInfo) error) error {\n    filepath.WalkDir(c.Path, func(path string, info fs.DirEntry, err error) error {\n        if err != nil {\n            return err\n        }\n\n        dirname := filepath.Base(path)\n        if dirname == ".nt" {\n            return fs.SkipDir // NB fs.SkipDir skip the parent dir when path is a file\n        }\n\n        relativePath, err := filepath.Rel(c.Path, path)\n        if err != nil {\n            // ignore the file\n            return nil\n        }\n\n        // We look for only specific extension\n        if !info.IsDir() && !strings.HasSuffix(relativePath, ".md") {\n            // Nothing to do\n            return nil\n        }\n\n        // Ignore certain file modes like symlinks\n        fileInfo, err := os.Lstat(path) // NB: os.Stat follows symlinks\n        if err != nil {\n            // Ignore the file\n            return nil\n        }\n        if !fileInfo.Mode().IsRegular() {\n            // Exclude any file with a mode bit set (device, socket, named pipe, ...)\n            // See https://pkg.go.dev/io/fs#FileMode\n            return nil\n        }\n\n        // A file found to process using the callback\n        err = fn(relativePath, fileInfo)\n        if err != nil {\n            return err\n        }\n\n        return nil\n    })\n\n    return nil\n}\n')),(0,r.kt)("p",null,"We will reuse this method several times later but now, we need to have a look at the database."),(0,r.kt)("h2",{id:"the-database"},"The Database"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type DB struct {\n    // .nt/index\n    index *Index\n    // .nt/database.sql\n    client *sql.DB\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Index")," represents the content of the database (= a list of known OIDs), including the staging area (= the objects that were added using ",(0,r.kt)("inlineCode",{parentName:"p"},"ntlite add")," but still not committed using ",(0,r.kt)("inlineCode",{parentName:"p"},"ntlite commit"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type Index struct {\n    Objects     []*IndexObject   `yaml:"objects"`\n    StagingArea []*StagingObject `yaml:"staging"`\n}\n\ntype IndexObject struct {\n    OID   string    `yaml:"oid"`\n    Kind  string    `yaml:"kind"`\n    MTime time.Time `yaml:"mtime"`\n}\n\ntype StagingObject struct {\n    IndexObject\n    State State      `yaml:"state"`\n    Data  ObjectData `yaml:"data"`\n}\n')),(0,r.kt)("p",null,"The index is a YAML file located at ",(0,r.kt)("inlineCode",{parentName:"p"},".nt/index"),". We define a few functions and methods to load and dump it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// ReadIndex loads the index file.\nfunc ReadIndex() *Index {\n    path := filepath.Join(CurrentCollection().Path, ".nt/index")\n    in, err := os.Open(path)\n    if errors.Is(err, os.ErrNotExist) {\n        // First use\n        return &Index{}\n    }\n    if err != nil {\n        log.Fatalf("Unable to open index: %v", err)\n    }\n    index := new(Index)\n    if err := index.Read(in); err != nil {\n        log.Fatalf("Unable to read index: %v", err)\n    }\n    in.Close()\n    return index\n}\n\n// Save persists the index on disk.\nfunc (i *Index) Save() error {\n    path := filepath.Join(CurrentCollection().Path, ".nt/index")\n    f, err := os.Create(path)\n    if err != nil {\n        return err\n    }\n    defer f.Close()\n    return i.Write(f)\n}\n\n// Read reads an index from the file.\nfunc (i *Index) Read(r io.Reader) error {\n    err := yaml.NewDecoder(r).Decode(&i)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\n// Write dumps the index to a file.\nfunc (i *Index) Write(w io.Writer) error {\n    data, err := yaml.Marshal(i)\n    if err != nil {\n        return err\n    }\n    _, err = w.Write(data)\n    return err\n}\n')),(0,r.kt)("p",null,"The other attribute of ",(0,r.kt)("inlineCode",{parentName:"p"},"DB")," is the connection to the SQLite database instance located at ",(0,r.kt)("inlineCode",{parentName:"p"},".nt/database.db"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func InitClient() *sql.DB {\n    db, err := sql.Open("sqlite3", filepath.Join(CurrentCollection().Path, ".nt/database.db"))\n    if err != nil {\n        fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\\n", err)\n        os.Exit(1)\n    }\n\n    // Create the schema\n    _, err = db.Exec(`\nCREATE TABLE IF NOT EXISTS file (\n    oid TEXT PRIMARY KEY,\n    relative_path TEXT NOT NULL,\n    body TEXT NOT NULL,\n    created_at TEXT NOT NULL,\n    updated_at TEXT NOT NULL,\n    last_checked_at TEXT,\n    mtime TEXT NOT NULL,\n    size INTEGER NOT NULL,\n    hashsum TEXT NOT NULL\n);\n\nCREATE TABLE IF NOT EXISTS note (\n    oid TEXT PRIMARY KEY,\n    file_oid TEXT NOT NULL,\n    relative_path TEXT NOT NULL,\n    title TEXT NOT NULL,\n    content_raw TEXT NOT NULL,\n    hashsum TEXT NOT NULL,\n    created_at TEXT NOT NULL,\n    updated_at TEXT NOT NULL,\n    last_checked_at TEXT\n);`)\n    if err != nil {\n        log.Fatalf("Error while initializing database: %v", err)\n    }\n\n    return db\n}\n')),(0,r.kt)("p",null,"We will use the standard ",(0,r.kt)("inlineCode",{parentName:"p"},"database/sql")," Go package to interact with the database. We will also expose a singleton to make easy to retrieve the connection:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"var (\n    dbOnce       sync.Once\n    dbSingleton  *DB\n)\n\nfunc CurrentDB() *DB {\n    dbOnce.Do(func() {\n        dbSingleton = &DB{\n            index: ReadIndex(),\n            client: InitClient(),\n        }\n    })\n    return dbSingleton\n}\n\n// Client returns the client to use to query the database.\nfunc (db *DB) Client() *sql.DB {\n    // This method will be completed later in this document\n    return db.client\n}\n")),(0,r.kt)("p",null,"Using this connection, we can now add methods on our model to persist the objects in the database:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func (f *File) Save() error {\n    var err error\n    f.UpdatedAt = time.Now()\n    f.LastCheckedAt = time.Now()\n    switch f.State() {\n    case Added:\n        err = f.Insert()\n    case Modified:\n        err = f.Update()\n    case Deleted:\n        err = f.Delete()\n    default:\n        err = f.Check()\n    }\n    if err != nil {\n        return err\n    }\n    f.new = false\n    f.stale = false\n    return nil\n}\n\nfunc (f *File) Insert() error {\n    query := `\n        INSERT INTO file(\n            oid,\n            relative_path,\n            body,\n            created_at,\n            updated_at,\n            last_checked_at,\n            mtime,\n            size,\n            hashsum\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?);\n    `\n    _, err := CurrentDB().Client().Exec(query,\n        f.OID,\n        f.RelativePath,\n        f.Body,\n        timeToSQL(f.CreatedAt),\n        timeToSQL(f.UpdatedAt),\n        timeToSQL(f.LastCheckedAt),\n        timeToSQL(f.MTime),\n        f.Size,\n        f.Hash,\n    )\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n\nfunc (f *File) Update() error {\n    query := `\n        UPDATE file\n        SET\n            relative_path = ?,\n            body = ?,\n            updated_at = ?,\n            last_checked_at = ?,\n            mtime = ?,\n            size = ?,\n            hashsum = ?\n        WHERE oid = ?;\n    `\n    _, err := CurrentDB().Client().Exec(query,\n        f.RelativePath,\n        f.Body,\n        timeToSQL(f.UpdatedAt),\n        timeToSQL(f.LastCheckedAt),\n        timeToSQL(f.MTime),\n        f.Size,\n        f.Hash,\n        f.OID,\n    )\n    return err\n}\n\nfunc (f *File) Delete() error {\n    query := `DELETE FROM file WHERE oid = ?;`\n    _, err := CurrentDB().Client().Exec(query, f.OID)\n    return err\n}\n\nfunc (f *File) Check() error {\n    client := CurrentDB().Client()\n    f.LastCheckedAt = time.Now()\n    query := `\n        UPDATE file\n        SET last_checked_at = ?\n        WHERE oid = ?;`\n    if _, err := client.Exec(query, timeToSQL(f.LastCheckedAt), f.OID); err != nil {\n        return err\n    }\n    query = `\n        UPDATE note\n        SET last_checked_at = ?\n        WHERE file_oid = ?;`\n    if _, err := client.Exec(query, timeToSQL(f.LastCheckedAt), f.OID); err != nil {\n        return err\n    }\n    return nil\n}\n")),(0,r.kt)("p",null,"That's a lot of code as we are using a low-level library. We have a method for every operation ",(0,r.kt)("inlineCode",{parentName:"p"},"Insert()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Update()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Delete()"),", and an additional method ",(0,r.kt)("inlineCode",{parentName:"p"},"Check()")," to only update the ",(0,r.kt)("inlineCode",{parentName:"p"},"LastCheckedAt")," timestamp. The method ",(0,r.kt)("inlineCode",{parentName:"p"},"Save()")," determines which method to call based on the attributes ",(0,r.kt)("inlineCode",{parentName:"p"},"new")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"stale"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The method ",(0,r.kt)("inlineCode",{parentName:"p"},"Save()")," for the model ",(0,r.kt)("inlineCode",{parentName:"p"},"Note")," is very similar and omitted for brievity.")),(0,r.kt)("p",null,"Before closing the section, there is still one issue to debate. Using ",(0,r.kt)("inlineCode",{parentName:"p"},"CurrentDB().Client()")," makes easy to execute queries but each query is executed inside a different transaction. When running commands, we will work on many objects at the same time. If a command fails to any reasons, we may want to rollback our changes and only report the error. We need to use transactions."),(0,r.kt)("h3",{id:"transactions"},"Transactions"),(0,r.kt)("p",null,"The standard type ",(0,r.kt)("inlineCode",{parentName:"p"},"sql.DB")," exposes a method ",(0,r.kt)("inlineCode",{parentName:"p"},"BeginTx")," that returns a variable of type ",(0,r.kt)("inlineCode",{parentName:"p"},"*sql.Tx")," useful to ",(0,r.kt)("inlineCode",{parentName:"p"},"Rollback()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Commit()")," the transaction. This object ",(0,r.kt)("inlineCode",{parentName:"p"},"sql.Tx")," exposes also different methods to query the database, the same methods as offered by ",(0,r.kt)("inlineCode",{parentName:"p"},"sql.DB"),", except there is no common interface between these two types. Ideally, we would like our methods ",(0,r.kt)("inlineCode",{parentName:"p"},"Save()")," to work if there are a transaction in progress or not. To solve this issue, we define an interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// Queryable provides a common interface between sql.DB and sql.Tx to make methods compatible with both.\ntype SQLClient interface {\n    ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)\n    Exec(query string, args ...any) (sql.Result, error)\n    QueryRow(query string, args ...any) *sql.Row\n    Query(query string, args ...any) (*sql.Rows, error)\n}\n")),(0,r.kt)("p",null,"We define only the few methods used by the application."),(0,r.kt)("p",null,"We also rework the method ",(0,r.kt)("inlineCode",{parentName:"p"},"Client()")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"DB")," to use this type and to return the default connection when no transaction was started (",(0,r.kt)("inlineCode",{parentName:"p"},"*sql.DB"),") or the current transaction (",(0,r.kt)("inlineCode",{parentName:"p"},"*sql.Tx"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type DB struct {\n    index *Index\n    client *sql.DB\n    tx *sql.Tx // NEW\n}\n\n// Client returns the client to use to query the database.\nfunc (db *DB) Client() SQLClient {\n    if db.tx != nil {\n        // Execute queries in current transaction\n        return db.tx\n    }\n    // Basic client = no transaction\n    return db.client\n}\n\n// BeginTransaction starts a new transaction.\nfunc (db *DB) BeginTransaction() error {\n    tx, err := db.client.BeginTx(context.Background(), nil)\n    if err != nil {\n        return err\n    }\n    db.tx = tx\n    return nil\n}\n\n// RollbackTransaction aborts the current transaction.\nfunc (db *DB) RollbackTransaction() error {\n    if db.tx == nil {\n        return errors.New("no transaction started")\n    }\n    err := db.tx.Rollback()\n    db.tx = nil\n    return err\n}\n\n// CommitTransaction ends the current transaction.\nfunc (db *DB) CommitTransaction() error {\n    if db.tx == nil {\n        return errors.New("no transaction started")\n    }\n    err := db.tx.Commit()\n    if err != nil {\n        return err\n    }\n    db.tx = nil\n    return nil\n}\n')),(0,r.kt)("p",null,"We will now implement the basic commands where these transactions will be indispensable."),(0,r.kt)("h2",{id:"the-commands"},"The Commands"),(0,r.kt)("h3",{id:"add"},(0,r.kt)("inlineCode",{parentName:"h3"},"add")),(0,r.kt)("p",null,"The command ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," updates the database with new objects. For this document, we consider only ",(0,r.kt)("inlineCode",{parentName:"p"},"File")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Note")," but ",(0,r.kt)("em",{parentName:"p"},"The NoteWriter")," manages more object types (",(0,r.kt)("inlineCode",{parentName:"p"},"Flashcard"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Reminder"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Link"),", ...). A common interface between these different types is useful to factorize code. For example, we want to add any type of object to the database in a uniform way. Here are the interfaces:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Object interface {\n    // Kind returns the object kind to determine which kind of object to create.\n    Kind() string\n    // UniqueOID returns the OID of the object.\n    UniqueOID() string\n    // ModificationTime returns the last modification time.\n    ModificationTime() time.Time\n\n    // SubObjects returns the objects directly contained by this object.\n    SubObjects() []StatefulObject\n\n    // Read rereads the object from YAML.\n    Read(r io.Reader) error\n    // Write writes the object to YAML.\n    Write(w io.Writer) error\n}\n\ntype StatefulObject interface {\n    Object\n\n    // State returns the current state.\n    State() State\n\n    // Save persists to DB\n    Save() error\n}\n")),(0,r.kt)("p",null,"In practice, all objects satisfy the ",(0,r.kt)("inlineCode",{parentName:"p"},"StatefulObject")," interface but we can choose to use one of two types to make explicit if we are interesting in reading the object or updating it."),(0,r.kt)("p",null,"The implementations of these methods is trivial. We have already covered the method ",(0,r.kt)("inlineCode",{parentName:"p"},"Save()"),". Here are the other methods implemented by the struct ",(0,r.kt)("inlineCode",{parentName:"p"},"File"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'\nfunc (f *File) Kind() string {\n    return "file"\n}\n\nfunc (f *File) UniqueOID() string {\n    return f.OID\n}\n\nfunc (f *File) State() State {\n    if !f.DeletedAt.IsZero() {\n        return Deleted\n    }\n    if f.new {\n        return Added\n    }\n    if f.stale {\n        return Modified\n    }\n    return None\n}\n\nfunc (f *File) ModificationTime() time.Time {\n    return f.MTime\n}\n\nfunc (f *File) Read(r io.Reader) error {\n    err := yaml.NewDecoder(r).Decode(f)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc (f *File) Write(w io.Writer) error {\n    data, err := yaml.Marshal(f)\n    if err != nil {\n        return err\n    }\n    _, err = w.Write(data)\n    return err\n}\n\nfunc (f *File) SubObjects() []StatefulObject {\n    var objs []StatefulObject\n\n    for _, object := range f.GetNotes() {\n        objs = append(objs, object)\n        objs = append(objs, object.SubObjects()...)\n    }\n    return objs\n}\n')),(0,r.kt)("p",null,"The last method ",(0,r.kt)("inlineCode",{parentName:"p"},"SubObjects()")," will be particularly useful when processing the collection of notes, since we will create objects of type ",(0,r.kt)("inlineCode",{parentName:"p"},"File")," and use ",(0,r.kt)("inlineCode",{parentName:"p"},"SubObjects()")," to iterate over other sub-objects recursively without having to interact directly with all types of objects."),(0,r.kt)("p",null,"Here is the code for the command ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func (c *Collection) Add() error {\n    db := CurrentDB()\n\n    // Run all queries inside the same transaction\n    err := db.BeginTransaction()\n    if err != nil {\n        return err\n    }\n    defer db.RollbackTransaction()\n\n    // Traverse all files\n    err = c.walk(func(relativePath string, stat fs.FileInfo) error {\n        file, err := NewOrExistingFile(relativePath)\n        if err != nil {\n            return err\n        }\n\n        if file.State() != None {\n            if err := db.StageObject(file); err != nil {\n                return fmt.Errorf("unable to stage modified object %s: %v", file.RelativePath, err)\n            }\n        }\n        if err := file.Save(); err != nil {\n            return nil\n        }\n\n        for _, object := range file.SubObjects() {\n            if object.State() != None {\n                if err := db.StageObject(object); err != nil {\n                    return fmt.Errorf("unable to stage modified object %s: %v", object, err)\n                }\n            }\n            if err := object.Save(); err != nil {\n                return err\n            }\n        }\n\n        return nil\n    })\n    if err != nil {\n        return err\n    }\n\n    // (Not implemented) Find objects to delete by querying\n    // the different tables for rows with last_checked_at < :execution_time\n\n    // Don\'t forget to commit\n    if err := db.CommitTransaction(); err != nil {\n        return err\n    }\n    // And to persist the index\n    if err := db.index.Save(); err != nil {\n        return err\n    }\n\n    return nil\n}\n')),(0,r.kt)("p",null,"We iterate over files using the ",(0,r.kt)("inlineCode",{parentName:"p"},"walk()")," method. We create a new ",(0,r.kt)("inlineCode",{parentName:"p"},"File")," using the newly function ",(0,r.kt)("inlineCode",{parentName:"p"},"NewOrExistingFile()")," whose goal is to check in database if the file is already known and compare for changes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func NewOrExistingFile(relativePath string) (*File, error) {\n    existingFile, err := CurrentCollection().LoadFileByPath(relativePath)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if existingFile != nil {\n        existingFile.update()\n        return existingFile, nil\n    }\n\n    parsedFile, err := ParseFile(relativePath)\n    if err != nil {\n        return nil, err\n    }\n    return NewFileFromParsedFile(parsedFile), nil\n}\n\nfunc (f *File) update() error {\n    absolutePath := filepath.Join(CurrentCollection().Path, f.RelativePath)\n    parsedFile, err := ParseFile(absolutePath)\n    if err != nil {\n        return err\n    }\n\n    // Check if local file has changed\n    if f.MTime != parsedFile.Stat.ModTime() || f.Size != parsedFile.Stat.Size() {\n        f.Size = parsedFile.Stat.Size()\n        f.Hash = Hash(parsedFile.Bytes)\n        f.MTime = parsedFile.Stat.ModTime()\n        f.Body = parsedFile.Body\n        f.stale = true\n    }\n\n    return nil\n}\n")),(0,r.kt)("p",null,"When the ",(0,r.kt)("inlineCode",{parentName:"p"},"State()")," of an object is different from ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," (= the object has changed), we place the object in the staging area (= the objects waiting to be committed). Then, we ",(0,r.kt)("inlineCode",{parentName:"p"},"Save()")," every object to at minimum update their ",(0,r.kt)("inlineCode",{parentName:"p"},"LastCheckedAt")," timestamp."),(0,r.kt)("p",null,"The only step remaining to be covered in more detail is the method ",(0,r.kt)("inlineCode",{parentName:"p"},"StageObject()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func (db *DB) StageObject(obj StatefulObject) error {\n    return db.index.StageObject(obj)\n}\n\nfunc (i *Index) StageObject(obj StatefulObject) error {\n    objData, err := NewObjectData(obj)\n    if err != nil {\n        return err\n    }\n\n    // Update staging area\n    stagingObject := &StagingObject{\n        IndexObject: IndexObject{\n            OID:   obj.UniqueOID(),\n            Kind:  obj.Kind(),\n            MTime: obj.ModificationTime(),\n        },\n        State: obj.State(),\n        Data:  objData,\n    }\n\n    i.StagingArea = append(i.StagingArea, stagingObject)\n\n    return nil\n}\n")),(0,r.kt)("p",null,"Basically, we append a new ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexObject")," into the slice ",(0,r.kt)("inlineCode",{parentName:"p"},"StagingArea")," defined by the struct ",(0,r.kt)("inlineCode",{parentName:"p"},"Index"),". What is more subtle to understand is the field ",(0,r.kt)("inlineCode",{parentName:"p"},"Data")," where the content of the staged object (can be any type) is serialized. Indeed, the index (and thus the staging area) is serialized in YAML. We serialize the content of all staged objects in ",(0,r.kt)("inlineCode",{parentName:"p"},"YAML")," before compressing it using the package ",(0,r.kt)("inlineCode",{parentName:"p"},"compress/zlib")," and encoding it in Base64 to end up with a simple string in ",(0,r.kt)("inlineCode",{parentName:"p"},"Data"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"staging:\n - oid: 93267c32147a4ab7a1100ce82faab56a99fca1cd\n   kind: note\n   state: added\n   mtime: 2023-01-01T01:12:30Z\n   data: eJzEUsFq20AQves...\n")),(0,r.kt)("p",null,"Here is a preview of this code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'import (\n    "bytes"\n    "compress/zlib"\n    "encoding/base64"\n)\n\n// ObjectData serializes any Object to base64 after zlib compression.\ntype ObjectData []byte // alias to serialize to YAML easily\n\n// NewObjectData creates a compressed-string representation of the object.\nfunc NewObjectData(obj Object) (ObjectData, error) {\n    b := new(bytes.Buffer)\n    if err := obj.Write(b); err != nil {\n        return nil, err\n    }\n    in := b.Bytes()\n\n    zb := new(bytes.Buffer)\n    w := zlib.NewWriter(zb)\n    w.Write(in)\n    w.Close()\n    return ObjectData(zb.Bytes()), nil\n}\n\nfunc (od ObjectData) MarshalYAML() (interface{}, error) {\n    return base64.StdEncoding.EncodeToString(od), nil\n}\n')),(0,r.kt)("p",null,"Saving the edited objects is particularly useful for deletions. When running the command ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),", there is a check (commented in the above code) to list all objects which have not be saved (= the objects that no longer exist) and we issue a ",(0,r.kt)("inlineCode",{parentName:"p"},"DELETE")," in database to remove them. This way, the objects disappear from the relational database (and the inverted index) and are not visible from the desktop UI. But if the user decides to run the command ",(0,r.kt)("inlineCode",{parentName:"p"},"reset")," (not supported in this document), we need to restore the content using the field ",(0,r.kt)("inlineCode",{parentName:"p"},"Data")," in the staging area."),(0,r.kt)("h3",{id:"commit"},(0,r.kt)("inlineCode",{parentName:"h3"},"commit")),(0,r.kt)("p",null,"The command ",(0,r.kt)("inlineCode",{parentName:"p"},"commit")," only interacts with the database (",(0,r.kt)("inlineCode",{parentName:"p"},"nt/objects"),") since the relational database was already updated when adding the files."),(0,r.kt)("p",null,"The goal of this command is to move the objects present inside the staging area to the final objects under ",(0,r.kt)("inlineCode",{parentName:"p"},".nt/objects"),". The file ",(0,r.kt)("inlineCode",{parentName:"p"},".nt/index")," must also be updated to empty the staging area and append the new objects in the reference list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// Commit creates a new commit object and clear the staging area.\nfunc (db *DB) Commit() error {\n    // Convert the staging area to object files under .nt/objects\n    for _, indexObject := range db.index.StagingArea {\n        var object Object\n\n        switch indexObject.Kind {\n        case "file":\n            var file File\n            if err := indexObject.Data.Unmarshal(&file); err != nil {\n                return err\n            }\n            object = &file\n        case "note":\n            var note Note\n            if err := indexObject.Data.Unmarshal(&note); err != nil {\n                return err\n            }\n            object = &note\n        }\n        objectPath := filepath.Join(CurrentCollection().Path, ".nt/objects", OIDToPath(indexObject.OID))\n        if err := os.MkdirAll(filepath.Dir(objectPath), os.ModePerm); err != nil {\n            return err\n        }\n        f, err := os.Create(objectPath)\n        if err != nil {\n            return err\n        }\n        defer f.Close()\n        err = object.Write(f)\n        if err != nil {\n            return err\n        }\n    }\n    db.index.ClearStagingArea()\n\n    // Save .nt/index\n    if err := db.index.Save(); err != nil {\n        return err\n    }\n    return nil\n}\n')),(0,r.kt)("p",null,"The code iterates over the elements present in the slice ",(0,r.kt)("inlineCode",{parentName:"p"},"StagingArea")," and decode/uncompress/unmarshall the objects before creating a new YAML file under ",(0,r.kt)("inlineCode",{parentName:"p"},".nt/objects"),"."),(0,r.kt)("p",null,"The code ends with a call to the method ",(0,r.kt)("inlineCode",{parentName:"p"},"ClearStagingArea()")," defined like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"\n// ClearStagingArea empties the staging area.\nfunc (i *Index) ClearStagingArea() {\n    for _, obj := range i.StagingArea {\n        i.Objects = append(i.Objects, &obj.IndexObject)\n    }\n    i.StagingArea = nil\n}\n")),(0,r.kt)("p",null,"Objects are migrated from the staging area to the list of all known objects. The command ",(0,r.kt)("inlineCode",{parentName:"p"},"commit")," ends by saving the file ",(0,r.kt)("inlineCode",{parentName:"p"},".nt/index"),"."),(0,r.kt)("p",null,"We are ready for the next batch of files to add. That's all for now."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"This minimalist version uses the same logic as the complete version"),". Here are a few notable differences:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"The NoteWriter")," uses Viper to have a more informative CLI output and support arguments to commands."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"The NoteWriter")," uses a ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/golang-migrate/migrate"},"migration tool")," to create the database schema. (see ",(0,r.kt)("inlineCode",{parentName:"li"},"initClient")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"internal/core/database.go"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"The NoteWriter")," supports more complex Markdown documents (ex: notes can be nested inside other notes)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"The NoteWriter")," supports attributes (and tags) defined using a YAML Front Matter and with a special syntax inside notes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"The NoteWriter")," processes notes to enrich their content (support note embedding or sugar syntax for quotes)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"The NoteWriter")," wraps objects inside ",(0,r.kt)("inlineCode",{parentName:"li"},".nt/objects")," inside ",(0,r.kt)("inlineCode",{parentName:"li"},"Commit")," object, regrouping all changes inside a single file. The OIDs of commits are also saved inside a file ",(0,r.kt)("inlineCode",{parentName:"li"},".nt/commit-graph"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"The NoteWriter")," supports remotes to push objects and synchronize them between devices. It reuses the file ",(0,r.kt)("inlineCode",{parentName:"li"},".nt/commit-graph")," to compare the commits and found the ones to push or pull."))))}m.isMDXComponent=!0}}]);