package core

import (
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"

	"github.com/julien-sobczak/the-notewriter/pkg/clock"
	"gopkg.in/yaml.v3"
)

// State describes an object status.
type State string

const (
	None     State = "none"
	Added    State = "added"
	Modified State = "modified"
	Deleted  State = "deleted"
)

/*
 * Index
 */

// Index
// See https://git-scm.com/docs/index-format for inspiration.
//
// The index file is used to determine if an object is new
// and to quickly locate the commit file containing the object otherwise.
// The index is particularly useful when adding or restoring objects.
type Index struct {
	// The "Three Trees"
	// See https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified
	Head        IndexTree
	StagingArea IndexTree

	// A list of pack files that are known to be orphans
	OrphanPackFiles []*IndexOrphanPackFile `yaml:"orphan_packfiles" json:"orphan_packfiles"`
	// A list of blobs that are known to be orphans
	OrphanBlobs []*IndexOrphanBlob `yaml:"orphan_blobs" json:"orphan_blobs"`
}

type IndexTree struct {
	PackFiles []*IndexPackFile `yaml:"packfiles" json:"packfiles"`
	Blobs     []*IndexBlob     `yaml:"blobs" json:"blobs"`
	Objects   []*IndexObject   `yaml:"objects" json:"objects"`
	// Same as `Objects` when searching by OID
	objectsRef map[string]*IndexObject `yaml:"-" json:"-"`
}

type IndexPackFile struct {
	PackFileRef

	// When nt add
	Staged   bool      `yaml:"-" json:"-"`
	StagedAt time.Time `yaml:"-" json:"-"`

	// TODO remove comment
	// When nt commit
	// Search for Staged and creates a commit containing all StagedOID

	// When nt status
	// List Staged, reread previous version from OID and make a diff

	// When nt reset
	// Delete PackFile on disk, clear Staged/StagedOID
}

type IndexBlob struct {
	BlobRef

	// When nt add
	Staged   bool      `yaml:"-" json:"-"`
	StagedAt time.Time `yaml:"-" json:"-"`
}

type IndexObject struct {
	OID   string    `yaml:"oid" json:"oid"`
	Kind  string    `yaml:"kind" json:"kind"`
	MTime time.Time `yaml:"mtime" json:"mtime"`
	// The packfile/commit containing the latest committed version (empty for uncommitted objects)
	LastPackFileOID string `yaml:"packfile_oid" json:"packfile_oid"`
	LastCommitOID   string `yaml:"commit_oid" json:"commit_oid"`
	// The packfile containing the latest staged version (empty for committed and not-modified objects)
	Staged            bool      `yaml:"-" json:"-"`
	StagedAt          time.Time `yaml:"-" json:"-"`
	StagedPackFileOID string    `yaml:"-" json:"-"`
}

type IndexOrphanPackFile struct {
	OID   string    `yaml:"oid" json:"oid"`
	DTime time.Time `yaml:"dtime" json:"dtime"`
}

type IndexOrphanBlob struct {
	OID   string    `yaml:"oid" json:"oid"`
	DTime time.Time `yaml:"dtime" json:"dtime"`
	// The media that introduced this blob
	MediaOID string `yaml:"media_oid" json:"media_oid"`
}

func (i IndexObject) String() string {
	return fmt.Sprintf("%s (%s)", i.Kind, i.OID)
}

/*
FIXME remove
// ReadStagingObject searches for the given staging object in staging area
func (sa *StagingArea) ReadStagingObject(objectOID string) (*StagingObject, bool) {
	for _, obj := range *sa {
		if obj.OID == objectOID {
			return obj, true
		}
	}
	return nil, false
}

// ReadObject searches for the given object in staging area
func (sa *StagingArea) ReadObject(objectOID string) (StatefulObject, bool) {
	obj, ok := sa.ReadStagingObject(objectOID)
	if !ok {
		return nil, false
	}
	return obj.ReadObject(), true
}
*/

// CountStagedObjects returns the number of objects inside the staging area.
func (i *Index) CountStagedPackFiles() int {
	// TODO remove this comment => Replace Count()
	count := 0
	for _, packFile := range i.PackFiles {
		if packFile.Staged {
			count += 1
		}
	}
	return count
}

// NewIndex instantiates a new index.
func NewIndex() *Index {
	return &Index{
		PackFiles:       []*IndexPackFile{},
		Blobs:           []*IndexBlob{},
		Objects:         []*IndexObject{},
		OrphanPackFiles: []*IndexOrphanPackFile{},
		OrphanBlobs:     []*IndexOrphanBlob{},
		// internal caches
		objectsRef: make(map[string]*IndexObject),
	}
}

// NewIndexFromPath loads an index file from a file.
func NewIndexFromPath(path string) (*Index, error) {
	in, err := os.Open(path)
	if errors.Is(err, os.ErrNotExist) {
		// First use
		return NewIndex(), nil
	}
	if err != nil {
		return nil, err
	}
	index := new(Index)
	if err := index.Read(in); err != nil {
		return nil, err
	}
	if index.objectsRef == nil {
		// Repopulate transient map
		index.objectsRef = make(map[string]*IndexObject)
		for _, object := range index.Objects {
			index.objectsRef[object.OID] = object
		}
	}
	in.Close()
	return index, nil
}

// CloneForRemote prepares a cleaned index before a push.
func (i *Index) CloneForRemote() *Index {
	remoteIndex := NewIndex()

	// Keep only pack files not staged
	for _, packFile := range i.PackFiles {
		if !packFile.Staged {
			remoteIndex.PackFiles = append(remoteIndex.PackFiles, packFile)
		}
	}
	// Keep only blobs not staged
	for _, blob := range i.Blobs {
		if !blob.Staged {
			remoteIndex.Blobs = append(remoteIndex.Blobs, blob)
		}
	}
	// Keep only objects not staged
	for _, object := range i.Objects {
		if !object.Staged {
			remoteIndex.Objects = append(remoteIndex.Objects, object)
			remoteIndex.objectsRef[object.OID] = object
		}
	}

	return remoteIndex
}

// Save persists the index on disk.
func (i *Index) Save() error {
	path := filepath.Join(CurrentConfig().RootDirectory, ".nt/index")
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return i.Write(f)
}

// ReadIndexObject searches for the given object in the index.
func (i *Index) ReadIndexObject(objectOID string) (*IndexObject, bool) {
	obj, ok := i.objectsRef[objectOID]
	return obj, ok
}

// FindCommitContaining returns the commit associated with a given object.
func (i *Index) FindCommitContaining(objectOID string) (string, bool) {
	indexFile, ok := i.objectsRef[objectOID]
	if !ok {
		return "", false
	}
	return indexFile.LastCommitOID, true
}

// FindPackFileContaining returns the pack file associated with a given object.
func (i *Index) FindPackFileContaining(objectOID string) (string, bool) {
	indexFile, ok := i.objectsRef[objectOID]
	if !ok {
		return "", false
	}
	return indexFile.LastPackFileOID, true
}

// IsOrphanPackFile checks if the pack file has already beeing deleted.
func (i *Index) IsOrphanPackFile(oid string) bool {
	for _, o := range i.OrphanPackFiles {
		if o.OID == oid {
			return true
		}
	}
	// not found
	return false
}

// IsOrphanBlob checks if the blob has already beeing deleted.
func (i *Index) IsOrphanBlob(oid string) bool {
	for _, o := range i.OrphanBlobs {
		if o.OID == oid {
			return true
		}
	}
	// not found
	return false
}

// StagePackFile adds a pack file to the staging area.
func (i *Index) StagePackFile(packFile *PackFile) {
	i.StagePackFileWithBlobs(packFile, nil)
}

// StagePackFile adds a pack file to the staging area.
func (i *Index) StagePackFileWithBlobs(packFile *PackFile, blobs []BlobRef) {
	stagedAt := clock.Now()

	indexPackFile := &IndexPackFile{
		PackFileRef: packFile.Ref(),

		Staged:   true,
		StagedAt: stagedAt,
	}

	i.PackFiles = append(i.PackFiles, indexPackFile)

	for _, packObject := range packFile.PackObjects {
		indexObject := &IndexObject{
			OID:               packObject.OID,
			Kind:              packObject.Kind,
			MTime:             packObject.MTime,
			Staged:            true,
			StagedAt:          stagedAt,
			StagedPackFileOID: packFile.OID,
		}
		i.Objects = append(i.Objects, indexObject)
		i.objectsRef[indexObject.OID] = indexObject
	}

	for _, blob := range blobs {
		indexBlob := &IndexBlob{
			BlobRef:  blob,
			Staged:   true,
			StagedAt: stagedAt,
		}
		i.Blobs = append(i.Blobs, indexBlob)
	}
}

// CreateCommit generates a new commit from current changes in the staging area.
func (i *Index) CreateCommitFromStagingArea() *Commit {
	commit := NewCommit()

	for _, packFile := range i.PackFiles {
		if packFile.Staged {
			packFile.Staged = false
			packFile.StagedAt = time.Time{}
			commit.AppendPackFile(packFile)
		}
	}
	for _, blob := range i.Blobs {
		if blob.Staged {
			blob.Staged = false
			blob.StagedAt = time.Time{}
			commit.AppendBlob(blob)
		}
	}
	for _, object := range i.Objects {
		if object.Staged {
			object.Staged = false
			object.StagedAt = time.Time{}
			object.LastPackFileOID = object.StagedPackFileOID
			object.LastCommitOID = commit.OID
			object.StagedPackFileOID = ""
		}
	}

	return commit
}

// Read read an index from the file.
func (i *Index) Read(r io.Reader) error {
	err := yaml.NewDecoder(r).Decode(&i)
	if err != nil {
		return err
	}
	return nil
}

// Write dumps the index to a file.
func (i *Index) Write(w io.Writer) error {
	data, err := yaml.Marshal(i)
	if err != nil {
		return err
	}
	_, err = w.Write(data)
	return err
}

type IndexDiff struct {
	// Objects present only in the compared index
	MissingObjects []*IndexObject
	// Pack Files no longer present in the compared index
	MissingOrphanPackFiles []string
	// Blobs no longer present in the compared index
	MissingOrphanBlobs []string
}

// Diff reports differences to reconcile the receiver with the given index.
func (i *Index) Diff(other *Index) *IndexDiff {
	result := new(IndexDiff)

	// Search for objects present in the given index and not present in the current index
	for _, objectOther := range other.Objects {
		if _, ok := i.objectsRef[objectOther.OID]; !ok {
			result.MissingObjects = append(result.MissingObjects, objectOther)
		}
	}
	// Search for orphan pack files present in the given index and not declared as such in the current index
	for _, orphanOther := range other.OrphanPackFiles {
		found := false
		for _, orphanLocal := range i.OrphanPackFiles {
			if orphanLocal.OID == orphanOther.OID {
				found = true
				break
			}
		}
		if !found {
			result.MissingOrphanPackFiles = append(result.MissingOrphanPackFiles, orphanOther.OID)
		}
	}
	// Search for orphan blobs present in the given index and not declared as such in the current index
	for _, orphanOther := range other.OrphanBlobs {
		found := false
		for _, orphanLocal := range i.OrphanBlobs {
			if orphanLocal.OID == orphanOther.OID {
				found = true
				break
			}
		}
		if !found {
			result.MissingOrphanBlobs = append(result.MissingOrphanBlobs, orphanOther.OID)
		}
	}

	return result
}

/*
 * Commit Graph
 */

// CommitGraph represents a .nt/objects/info/commit-graph file.
// See https://git-scm.com/docs/commit-graph for inspiration.
//
// The commit graph is used to quickly finds commit to download
// and/or diffs between local and remote directories.
// Useful when pulling or pushing commits.
type CommitGraph struct {
	UpdatedAt time.Time `yaml:"updated_at,omitempty" json:"updated_at,omitempty"`
	Commits   []*Commit `yaml:"commits,omitempty" json:"commits,omitempty"`
}

// NewCommitGraph instantiates a new commit graph.
func NewCommitGraph() *CommitGraph {
	return &CommitGraph{
		UpdatedAt: clock.Now(),
	}
}

// NewCommitGraphFromPath loads a commit-graph file from a path.
func NewCommitGraphFromPath(path string) (*CommitGraph, error) {
	in, err := os.Open(path)
	if errors.Is(err, os.ErrNotExist) {
		// First use
		return NewCommitGraph(), nil
	}
	if err != nil {
		return nil, err
	}
	cg := new(CommitGraph)
	if err := cg.Read(in); err != nil {
		return nil, err
	}
	in.Close()
	return cg, nil
}

// Read instantiates a commit graph from an existing file
func (cg *CommitGraph) Read(r io.Reader) error {
	err := yaml.NewDecoder(r).Decode(&cg)
	if err != nil {
		return err
	}
	return nil
}

// AppendCommit pushes a new commit.
func (c *CommitGraph) AppendCommit(commit *Commit) error {
	c.UpdatedAt = clock.Now()
	c.Commits = append(c.Commits, commit)
	return nil
}

// Ref returns the commit OID of the last commit.
func (c *CommitGraph) Ref() string {
	if len(c.Commits) == 0 {
		return ""
	}
	return c.Commits[len(c.Commits)-1].OID
}

// LastCommits returns all commits pushed after head.
func (c *CommitGraph) LastCommitsFrom(head string) ([]*Commit, error) {
	var results []*Commit

	found := false
	for _, commit := range c.Commits {
		if found {
			// Already found head = recent commit
			results = append(results, commit)
		}
		if commit.OID == head {
			found = true
		}
	}

	if !found {
		return nil, fmt.Errorf("unknown commit %s", head)
	}

	return results, nil
}

type CommitGraphDiff struct {
	// Commits present only in the compared commit graph
	MissingCommits []*Commit
	// Pack files present only in the compared commit graph
	MissingPackFiles PackFileRefs
	// Pack files no longer present in the compared commit graph
	ObsoletePackFiles PackFileRefs
	// Pack files edited since by a gc
	EditedPackFiles PackFileRefs
}

// Diff reports differences to reconcile the receiver with the given commit graph.
func (c *CommitGraph) Diff(other *CommitGraph) *CommitGraphDiff {
	result := new(CommitGraphDiff)

	for _, commitOther := range other.Commits {
		found := false
		for _, commitLocal := range c.Commits {
			if commitLocal.OID == commitOther.OID {
				found = true

				// Great, the commit is present on both sides.
				// Let's compare the content to see if GC has updated it
				for _, packFileOther := range commitOther.PackFiles {
					packFileLocal, ok := commitLocal.IncludePackFile(packFileOther.OID)
					if !ok {
						result.MissingPackFiles = append(result.MissingPackFiles, packFileOther)
						continue
					}
					if packFileLocal.MTime.Before(packFileOther.MTime) {
						result.EditedPackFiles = append(result.EditedPackFiles, packFileOther)
					}
				}
				for _, packFileLocal := range commitLocal.PackFiles {
					_, ok := commitOther.IncludePackFile(packFileLocal.OID)
					if !ok {
						result.ObsoletePackFiles = append(result.ObsoletePackFiles, packFileLocal)
					}
				}

				break
			}
		}
		if !found {
			result.MissingCommits = append(result.MissingCommits, commitOther)
		}
	}

	return result
}

// Dump must be used for debug purpose only.
func (c *CommitGraph) Dump() {
	fmt.Println("\n> Commit Graph:")
	for _, commit := range c.Commits {
		fmt.Printf("  - %s\n", commit.OID)
		for _, packFile := range commit.PackFiles {
			fmt.Printf("    %s (last: %s)\n", packFile.OID, packFile.MTime)
		}
	}
	fmt.Println()
}

// Write dumps the commit graph.
func (c *CommitGraph) Write(w io.Writer) error {
	data, err := yaml.Marshal(c)
	if err != nil {
		return err
	}
	_, err = w.Write(data)
	return err
}

// Save persists the commit-graph locally.
func (c *CommitGraph) Save() error {
	path := filepath.Join(CurrentConfig().RootDirectory, ".nt/objects/info/commit-graph")
	return c.SaveTo(path)
}

// SaveTo persists the commit-graph to the given path.
func (c *CommitGraph) SaveTo(path string) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return err
	}
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	return c.Write(f)
}

/*
 * Commit
 */

type Commit struct {
	OID       string       `yaml:"oid" json:"oid"`
	CTime     time.Time    `yaml:"ctime" json:"ctime"`
	MTime     time.Time    `yaml:"mtime" json:"mtime"`
	PackFiles PackFileRefs `yaml:"packfiles" json:"packfiles"`
	Blobs     BlobRefs     `yaml:"blobs" json:"blobs"`
}

// NewCommit initializes a new empty commit.
func NewCommit() *Commit {
	return &Commit{
		OID:   NewOID(),
		CTime: clock.Now(),
		MTime: clock.Now(),
	}
}

// NewCommitWithOID initializes a new commit with a given OID.
func NewCommitWithOID(oid string) *Commit {
	return &Commit{
		OID:   oid,
		CTime: clock.Now(),
		MTime: clock.Now(),
	}
}

// AppendPackFile appends a new pack file OID in the commit.
func (c *Commit) AppendPackFile(packFile *IndexPackFile) {
	c.PackFiles = append(c.PackFiles, packFile.PackFileRef)
}

// AppendPackFile appends a new pack file OID in the commit.
func (c *Commit) AppendBlob(blob *IndexBlob) {
	c.Blobs = append(c.Blobs, blob.BlobRef)
}

// IncludePackFile returns the pack file is present in the commit.
func (c *Commit) IncludePackFile(oid string) (*PackFileRef, bool) {
	for _, packFile := range c.PackFiles {
		if packFile.OID == oid {
			return &packFile, true
		}
	}
	return nil, false
}

func (c Commit) String() string {
	return fmt.Sprintf("%s (including %d pack files)", c.OID, len(c.PackFiles))
}

/* Dumpable */

func (c *Commit) ToYAML() string {
	return ToBeautifulYAML(c)
}

func (c *Commit) ToJSON() string {
	return ToBeautifulJSON(c)
}

func (c *Commit) ToMarkdown() string {
	return fmt.Sprintf("Commit %s\n", c.OID)
}
