package core

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	godiffpatch "github.com/sourcegraph/go-diff-patch"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)



func TestCommandGC(t *testing.T) {

	t.Run("Reclaim Orphan Blobs", func(t *testing.T) {
		root := SetUpRepositoryFromGoldenDirNamed(t, "TestMinimal")

		// Configure origin
		origin := t.TempDir()
		CurrentConfig().ConfigFile.Remote = ConfigRemote{
			Type: "fs",
			Dir:  origin,
		}

		err := CurrentRepository().Add(".")
		require.NoError(t, err)
		err = CurrentDB().Commit("initial commit")
		require.NoError(t, err)
		err = CurrentDB().Push()
		require.NoError(t, err)
		logo, err := CurrentRepository().FindMediaByRelativePath("medias/go.svg")
		require.NoError(t, err)
		require.NotNil(t, logo)
		require.Len(t, logo.BlobRefs, 3)
		logoOriginalBlob := logo.BlobRefs[0]
		// Check local
		require.FileExists(t, filepath.Join(root, ".nt/objects/", OIDToPath(logoOriginalBlob.OID)))
		// Check origin
		require.FileExists(t, filepath.Join(origin, OIDToPath(logoOriginalBlob.OID)))

		// Update the media file
		err = os.WriteFile(filepath.Join(root, "go.md"), []byte(`
# Go

## Flashcard: Golang Logo

What does the **Golang logo** represent?

---

A **gopher**.

![Logo](./medias/go.png)
`), 0644)
		require.NoError(t, err)

		err = CurrentRepository().Add(".") // To force medias cleaning
		require.NoError(t, err)
		err = CurrentDB().Commit("update go.svg -> go.png")
		require.NoError(t, err)
		err = CurrentDB().Push()
		require.NoError(t, err)

		logo, err = CurrentRepository().FindMediaByRelativePath("medias/go.svg")
		require.NoError(t, err)
		require.Nil(t, logo) // Old file must not longer exist
		logo, err = CurrentRepository().FindMediaByRelativePath("medias/go.png")
		require.NoError(t, err)
		require.NotNil(t, logo) // No file must now exist
		require.Len(t, logo.BlobRefs, 2)
		logoModifiedBlob := logo.BlobRefs[0]
		require.NotEqual(t, logoOriginalBlob.OID, logoModifiedBlob.OID) // Must be different blobs
		// Check local
		require.FileExists(t, filepath.Join(root, ".nt/objects/", OIDToPath(logoOriginalBlob.OID))) // Must still exists
		require.FileExists(t, filepath.Join(root, ".nt/objects/", OIDToPath(logoModifiedBlob.OID)))
		// Check origin
		require.FileExists(t, filepath.Join(origin, OIDToPath(logoOriginalBlob.OID))) // Must still exists
		require.FileExists(t, filepath.Join(origin, OIDToPath(logoModifiedBlob.OID)))

		// Run "nt gc"
		err = CurrentDB().GC()
		require.NoError(t, err)
		// Only the referenced blob must now exists
		// Check local
		require.NoFileExists(t, filepath.Join(root, ".nt/objects/", OIDToPath(logoOriginalBlob.OID))) // garbage collected
		require.FileExists(t, filepath.Join(root, ".nt/objects/", OIDToPath(logoModifiedBlob.OID)))
		// Check origin
		require.FileExists(t, filepath.Join(origin, OIDToPath(logoOriginalBlob.OID))) // not garbage collected by this command
		require.FileExists(t, filepath.Join(origin, OIDToPath(logoModifiedBlob.OID)))

		// Run "nt push"
		err = CurrentDB().Push() // apply local gc changes
		require.NoError(t, err)
		require.NoFileExists(t, filepath.Join(origin, OIDToPath(logoOriginalBlob.OID))) // garbage collected
		require.FileExists(t, filepath.Join(origin, OIDToPath(logoModifiedBlob.OID)))
	})

	t.Run("Edit PackFiles", func(t *testing.T) {
		root := SetUpRepositoryFromTempDir(t)

		// Configure origin
		origin := t.TempDir()
		CurrentConfig().ConfigFile.Remote = ConfigRemote{
			Type: "fs",
			Dir:  origin,
		}

		// Limit the number of objects per pack file to ease debugging
		maxObjectsPerPackFile := 3
		CurrentConfig().ConfigFile.Core.MaxObjectsPerPackFile = maxObjectsPerPackFile

		// Step 1:
		// ------
		// Create two files containing many notes by ensuring we have several packfiles:
		// - A pack file containing only objects coming from file A
		// - A pack file containing objects coming from file A AND file B
		// - A pack file containing only objects coming from file B
		maxNotesPerFile := maxObjectsPerPackFile + 1
		var contentA bytes.Buffer
		contentA.WriteString("# New File A\n\n")
		for i := 0; i < maxNotesPerFile; i++ {
			contentA.WriteString(fmt.Sprintf("## Note: A%d\n\nBlabla\n\n", i+1))
		}
		err := os.WriteFile(filepath.Join(root, "a.md"), contentA.Bytes(), 0644)
		require.NoError(t, err)

		var contentB bytes.Buffer
		contentB.WriteString("# New File A\n\n")
		for i := 0; i < maxNotesPerFile; i++ {
			contentB.WriteString(fmt.Sprintf("## Note: B%d\n\nBlabla\n\n", i+1))
		}
		err = os.WriteFile(filepath.Join(root, "b.md"), contentB.Bytes(), 0644)
		require.NoError(t, err)

		// Commit
		err = CurrentRepository().Add(".")
		require.NoError(t, err)
		err = CurrentDB().Commit("initial commit")
		require.NoError(t, err)
		err = CurrentDB().Push()
		require.NoError(t, err)

		// Inspect commit
		initialCommit := CurrentDB().Head()
		require.NotNil(t, initialCommit)
		require.Len(t, initialCommit.PackFiles, 4)
		initialPackFilesOIDs := initialCommit.PackFiles.OIDs() // Backup to compare later after gc

		// Inspect stats
		statsOnDisk, err := CurrentDB().StatsOnDisk()
		require.NoError(t, err)
		assert.Equal(t, statsOnDisk.Commits, 1)
		assert.Equal(t, statsOnDisk.Objects["file"], 2)
		assert.Equal(t, statsOnDisk.Objects["note"], maxNotesPerFile*2) // file A + file B
		assert.Equal(t, statsOnDisk.IndexObjects, maxNotesPerFile*2+2)

		CurrentDB().PrintIndex()

		// Step 2:
		// ------
		// We will now completely edit the file A and commit again
		contentA.Reset()
		contentA.WriteString("# New File A\n\n")
		for i := 0; i < maxNotesPerFile; i++ {
			contentA.WriteString(fmt.Sprintf("## Note: A%d\n\nBlablaBlaBla\n\n", i+1)) // New text
		}
		err = os.WriteFile(filepath.Join(root, "a.md"), contentA.Bytes(), 0644)
		require.NoError(t, err)

		// Commit
		err = CurrentRepository().Add(".")
		require.NoError(t, err)
		err = CurrentDB().Commit("second commit")
		require.NoError(t, err)
		err = CurrentDB().Push()
		require.NoError(t, err)

		// We now have two commits. The second commit rewrite all objects coming from file A.
		// It means:
		// - The first pack file of the initial commit can be reclaimed (contains only old versions).
		// - The second pack file of the initial commit can be edited to remove objects from file A.
		// - The third pack file of the initial commit must be left untouched as the pack files from the second commit.

		statsOnDisk, err = CurrentDB().StatsOnDisk()
		require.NoError(t, err)
		assert.Equal(t, statsOnDisk.Commits, 2)
		assert.Equal(t, statsOnDisk.Objects["file"], 3)                 // old file A + actual file A + actual file B
		assert.Equal(t, statsOnDisk.Objects["note"], maxNotesPerFile*3) // Same logic
		assert.Equal(t, statsOnDisk.IndexObjects, maxNotesPerFile*2+2)

		CurrentDB().PrintIndex()

		// Step 3:
		// ------
		// Run the GC locally
		// We must still have 2 commits but the old revisions must no longer exist.

		// Run "nt gc"
		err = CurrentDB().GC()
		require.NoError(t, err)

		// Inspect stats
		statsOnDisk, err = CurrentDB().StatsOnDisk()
		require.NoError(t, err)
		assert.Equal(t, statsOnDisk.Commits, 2)                         // unchanged
		assert.Equal(t, statsOnDisk.Objects["file"], 2)                 // only actual files ...
		assert.Equal(t, statsOnDisk.Objects["note"], maxNotesPerFile*2) // ... and actual notes

		// Let's inspect the first commit content to validate
		initialCommitEdited, ok := CurrentDB().ReadCommit(initialCommit.OID)
		require.True(t, ok)
		assert.Len(t, initialCommitEdited.PackFiles, 3) // The first pack file must have been dropped
		packFile1, err := CurrentDB().ReadPackFile(initialCommitEdited.PackFiles[0].OID)
		require.NoError(t, err)
		packFile2, err := CurrentDB().ReadPackFile(initialCommitEdited.PackFiles[1].OID)
		require.NoError(t, err)
		// Ensure only objects from file B remains
		var allPackObjects []*PackObject
		allPackObjects = append(allPackObjects, packFile1.PackObjects...)
		allPackObjects = append(allPackObjects, packFile2.PackObjects...)
		for _, packObject := range allPackObjects {
			obj := packObject.ReadObject()
			switch typedObject := obj.(type) {
			case *File:
				require.Equal(t, "b.md", typedObject.RelativePath)
			case *Note:
				require.Equal(t, "b.md", typedObject.RelativePath)
			}
		}

		// Step 4:
		// ------
		// Push to apply GC changes remotely
		// We must reclaim the same objects as in step 3.
		// But first check for timestamps before the operation
		path1 := filepath.Join(origin, OIDToPath(initialPackFilesOIDs[0]))
		path2 := filepath.Join(origin, OIDToPath(initialPackFilesOIDs[1]))
		path3 := filepath.Join(origin, OIDToPath(initialPackFilesOIDs[2]))
		path4 := filepath.Join(origin, OIDToPath(initialPackFilesOIDs[3]))
		timestamp2Before := MustReadMTime(t, path2)
		timestamp3Before := MustReadMTime(t, path3)
		timestamp4Before := MustReadMTime(t, path4)
		err = CurrentDB().Push()
		require.NoError(t, err)
		require.NoFileExists(t, path1) // garbage collected
		require.FileExists(t, path2)   // edited
		require.FileExists(t, path3)   // unchanged
		require.FileExists(t, path4)   // unchanged
		timestamp2After := MustReadMTime(t, path2)
		timestamp3After := MustReadMTime(t, path3)
		timestamp4After := MustReadMTime(t, path4)
		assert.NotEqual(t, timestamp2Before, timestamp2After) // edited
		assert.Equal(t, timestamp3Before, timestamp3After)    // unchanged
		assert.Equal(t, timestamp4Before, timestamp4After)    // unchanged
	})

}
